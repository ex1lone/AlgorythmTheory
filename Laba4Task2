#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

int a = 0, b = 0;
int m = 13;

double A = 0.6180339887;

typedef struct {
    char ch[4];
    int val;
} LetterEntry;

LetterEntry letters[] = {
    {"А",1},{"Б",2},{"В",3},{"Г",4},{"Ґ",5},{"Д",6},{"Е",7},{"Є",8},
    {"Ж",9},{"З",10},{"И",11},{"І",12},{"Ї",13},{"Й",14},{"К",15},{"Л",16},
    {"М",17},{"Н",18},{"О",19},{"П",20},{"Р",21},{"С",22},{"Т",23},{"У",24},
    {"Ф",25},{"Х",26},{"Ц",27},{"Ч",28},{"Ш",29},{"Щ",30},{"Ь",31},
    {"Ю",32},{"Я",33}
};

int getLetterValue(const char* utf8) {
    for (int i = 0; i < 33; i++) {
        if (strcmp(utf8, letters[i].ch) == 0) return letters[i].val;
    }
    return 0;
}

int nextUChar(const char* s, int* bytes) {
    unsigned char c = (unsigned char)s[0];
    if (c < 128) { *bytes = 1; return 1; }
    else if ((c >> 5) == 0x6) { *bytes = 2; }
    else if ((c >> 4) == 0xE) { *bytes = 3; }
    else if ((c >> 3) == 0x1E) { *bytes = 4; }
    else { *bytes = 1; }
    return *bytes;
}

int hashDivide(const char* word) {
    int sum = 0;
    int i = 0, bytes = 0;
    char buff[5];

    while (word[i]) {
        nextUChar(word + i, &bytes);
        memcpy(buff, word + i, bytes);
        buff[bytes] = '\0';

        int val = getLetterValue(buff);

        sum += val;
        i += bytes;
    }

    if (a < 7) {
        printf("Слово: %s\n\tСума: %d\n", word, sum);
        a++;
    }

    return sum % m;
}

int hashMultiply(const char* word) {
    int sum = 0;
    int i = 0, bytes = 0;
    char buff[5];

    while (word[i]) {
        nextUChar(word + i, &bytes);
        memcpy(buff, word + i, bytes);
        buff[bytes] = '\0';

        int val = getLetterValue(buff);

        sum += val;
        i += bytes;
    }

    if (b < 7) {
        printf("Слово: %s\n\tСума: %d\n", word, sum);
        b++;
    }

    double frac = fmod(sum * A, 1.0);
    return (int)floor(m * frac);
}

char** buildClosedHashTable(const char** words, int count, int mode) {
    char** table = calloc(m, sizeof(char*));

    for (int w = 0; w < count; w++) {
        const char* word = words[w];
        int start = (mode == 0) ? hashDivide(word) : hashMultiply(word);
        int inserted = 0;

        for (int i = 0; i < m; i++) {
            int addr = (start + i) % m;

            if (table[addr] == NULL) {
                table[addr] = strdup(word);
                inserted = 1;
                break;
            }
        }

        if (!inserted) printf("Таблиця повна, неможливо додати: %s\n", word);
    }

    return table;
}

void displayHashTable(char** table) {
    printf("\nТаблиця для m = %d\n", m);
    for (int i = 0; i < m; i++) {
        printf("Комірка:%3d   Слово: %s\n", i, table[i] ? table[i] : "[]");
    }
}

void search(char** table, int mode) {
    int total = 0, maxComp = 0;
    char maxWord[128] = "";
    int count = 0;

    for (int i = 0; i < m; i++) {
        if (table[i] == NULL) continue;

        count++;

        const char* word = table[i];
        int start = (mode == 0) ? hashDivide(word) : hashMultiply(word);

        int j = 0, comparisons = 0;
        while (j < m) {
            int pos = (start + j) % m;
            comparisons++;

            if (table[pos] && strcmp(table[pos], word) == 0) break;
            j++;
        }

        total += comparisons;

        if (comparisons > maxComp) {
            maxComp = comparisons;
            strcpy(maxWord, word);
        }
    }

    double avg = (count == 0) ? 0 : (double)total / count;

    printf("Слово з найбільшою кількість порівнянь: %s (%d)\n", maxWord, maxComp);
    printf("Середня кількість порівнянь: %.2f\n", avg);
}

int main() {

    system("chcp 65001");

    const char* words[] = {
        "ЧУЖУ", "БІДУ", "РУКАМИ", "РОЗВЕДУ", "А", "ДО", "СВОЄЇ", "РОЗУМУ", "НЕ","ДІЙДУ"
    };

    int count = 7;

    char** table1 = buildClosedHashTable(words, count, 0);
    displayHashTable(table1);
    search(table1, 0);

    printf("\n\n\n");

    m = 16;

    char** table2 = buildClosedHashTable(words, count, 1);
    displayHashTable(table2);
    search(table2, 1);

    return 0;
}
